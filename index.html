<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>iPhone Bewegungserfassung</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            touch-action: none;
        }
        #container { 
            position: absolute; 
            width: 100%; 
            height: 100%; 
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 10px;
        }
        button {
            padding: 10px 15px;
            margin: 5px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            background: #007AFF;
            color: white;
        }
        button:disabled {
            background: #cccccc;
        }
        #status {
            margin-top: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="ui">
        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="downloadBtn" disabled>Download STL</button>
        <div id="status">Bereit</div>
        <div id="pointCount">Punkte: 0</div>
    </div>

    <script>
        // Globale Variablen
        let isRecording = false;
        let points = [];
        let referenceQuaternion = null;
        let scene, camera, renderer, controls, pointCloud, pointGeometry, pointMaterial;
        
        // Initialisierung
        init();
        
        function init() {
            // Three.js Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            
            // Licht
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 1);
            scene.add(light);
            
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            // Achsen-Helfer
            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);
            
            // Punktwolke initialisieren
            pointGeometry = new THREE.BufferGeometry();
            pointMaterial = new THREE.PointsMaterial({
                color: 0xff0000,
                size: 0.05,
                sizeAttenuation: true
            });
            
            pointCloud = new THREE.Points(pointGeometry, pointMaterial);
            scene.add(pointCloud);
            
            // Event Listener
            window.addEventListener('resize', onWindowResize);
            document.getElementById('startBtn').addEventListener('click', startRecording);
            document.getElementById('stopBtn').addEventListener('click', stopRecording);
            document.getElementById('downloadBtn').addEventListener('click', downloadSTL);
            
            // Animation Loop
            animate();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function startRecording() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ benötigt Berechtigung
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            initRecording();
                        } else {
                            document.getElementById('status').textContent = 'Berechtigung verweigert';
                        }
                    })
                    .catch(console.error);
            } else {
                initRecording();
            }
        }
        
        function initRecording() {
            isRecording = true;
            points = [];
            referenceQuaternion = null;
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('downloadBtn').disabled = true;
            document.getElementById('status').textContent = 'Aufzeichnung läuft';
            document.getElementById('pointCount').textContent = 'Punkte: 0';
            
            // Event Listener für Geräteorientierung
            window.addEventListener('deviceorientation', handleOrientation);
        }
        
        function stopRecording() {
            isRecording = false;
            window.removeEventListener('deviceorientation', handleOrientation);
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('downloadBtn').disabled = false;
            document.getElementById('status').textContent = 'Aufzeichnung gestoppt';
            
            updatePointCloud();
        }
        
        function handleOrientation(event) {
            if (!isRecording) return;
            
            // Quaternion aus den Rotationsdaten berechnen
            const alpha = THREE.MathUtils.degToRad(event.alpha);  // Z-Achse
            const beta = THREE.MathUtils.degToRad(event.beta);    // X-Achse
            const gamma = THREE.MathUtils.degToRad(event.gamma);  // Y-Achse
            
            const quaternion = new THREE.Quaternion();
            quaternion.setFromEuler(new THREE.Euler(beta, alpha, -gamma, 'YXZ'));
            
            // Ersten Quaternion als Referenz speichern
            if (!referenceQuaternion) {
                referenceQuaternion = quaternion.clone().invert();
            }
            
            // Relative Rotation berechnen
            const relativeQuaternion = referenceQuaternion.clone().multiply(quaternion);
            
            // Position berechnen (hier einfach die Richtung als Position verwenden)
            const position = new THREE.Vector3(0, 0, -1).applyQuaternion(relativeQuaternion);
            
            // Punkt hinzufügen
            points.push(position);
            document.getElementById('pointCount').textContent = `Punkte: ${points.length}`;
            
            // Punktwolke alle 10 Punkte aktualisieren für bessere Performance
            if (points.length % 10 === 0) {
                updatePointCloud();
            }
        }
        
        function updatePointCloud() {
            const positions = new Float32Array(points.length * 3);
            
            for (let i = 0; i < points.length; i++) {
                positions[i * 3] = points[i].x;
                positions[i * 3 + 1] = points[i].y;
                positions[i * 3 + 2] = points[i].z;
            }
            
            pointGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            pointGeometry.attributes.position.needsUpdate = true;
        }
        
        function downloadSTL() {
            if (points.length === 0) return;
            
            // Erstelle ein Mesh aus den Punkten (hier sehr einfache Konvertierung)
            const vertices = [];
            const faces = [];
            
            // Füge für jeden Punkt eine kleine Kugel hinzu
            const sphereGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const mergedGeometry = new THREE.BufferGeometry();
            
            for (let i = 0; i < points.length; i++) {
                const sphere = sphereGeometry.clone();
                sphere.translate(points[i].x, points[i].y, points[i].z);
                
                // Merge Geometries
                if (i === 0) {
                    mergedGeometry.copy(sphere);
                } else {
                    const positionAttribute = sphere.getAttribute('position');
                    const indexAttribute = sphere.getIndex();
                    
                    const mergedPositionAttribute = mergedGeometry.getAttribute('position');
                    const mergedIndexAttribute = mergedGeometry.getIndex();
                    
                    const newPositionAttribute = new THREE.BufferAttribute(
                        new Float32Array(mergedPositionAttribute.count + positionAttribute.count), 
                        3
                    );
                    
                    for (let j = 0; j < mergedPositionAttribute.count; j++) {
                        newPositionAttribute.setXYZ(
                            j,
                            mergedPositionAttribute.getX(j),
                            mergedPositionAttribute.getY(j),
                            mergedPositionAttribute.getZ(j)
                        );
                    }
                    
                    for (let j = 0; j < positionAttribute.count; j++) {
                        newPositionAttribute.setXYZ(
                            mergedPositionAttribute.count + j,
                            positionAttribute.getX(j),
                            positionAttribute.getY(j),
                            positionAttribute.getZ(j)
                        );
                    }
                    
                    const newIndexAttribute = new THREE.BufferAttribute(
                        new Uint32Array((mergedIndexAttribute ? mergedIndexAttribute.count : 0) + indexAttribute.count), 
                        1
                    );
                    
                    if (mergedIndexAttribute) {
                        for (let j = 0; j < mergedIndexAttribute.count; j++) {
                            newIndexAttribute.setX(j, mergedIndexAttribute.getX(j));
                        }
                    }
                    
                    const indexOffset = mergedPositionAttribute.count;
                    for (let j = 0; j < indexAttribute.count; j++) {
                        newIndexAttribute.setX(
                            (mergedIndexAttribute ? mergedIndexAttribute.count : 0) + j,
                            indexAttribute.getX(j) + indexOffset
                        );
                    }
                    
                    mergedGeometry.setAttribute('position', newPositionAttribute);
                    mergedGeometry.setIndex(newIndexAttribute);
                }
            }
            
            // Export als STL
            const exporter = new THREE.STLExporter();
            const stlString = exporter.parse(new THREE.Mesh(mergedGeometry, new THREE.MeshBasicMaterial()));
            
            // Download
            const blob = new Blob([stlString], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'bewegungspunktwolke.stl';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>
